# Скрытие POI за зданиями. Сокращенная версия

*Научились скрывать наши POI за 3D-объектами*

Приход в карту иммерсивных возможностей начал менять сложившееся положение вещей  --- моделей стало больше, они стали красивее и детальнее, появилось больше желания призумиться и рассматривать их. И тут возникла проблема с POI:

![POI игнорируют 3D](problem.png)

Наши POI (иконки и надписи организаций и значимых мест) по-прежнему ощущают себя на двухмерной карте, игнорируя трехмерные геометрии. Это дизориентирует и создает визуальный мусор, ведь глядя на башни Сити меньше всего хочешь видеть иконки находящиеся  за 300-700 метров позади. Нужно было научить наши POI корректно рисоваться вместе с 3D объектами, скрываясь за ними при необходимости.

И мы начали экспериментировать.
## Решение при помощи буфера глубины

WebGL, как и все другие трехмерные API, предоставляет стандартную возможность для скрытия одних 3D объектов другими - [буфер глубины](https://ru.wikipedia.org/wiki/Z-буферизация). Если просто взять POI и включить им глубину, картинка будет следующая:

![Отрисовка POI с просто включенным буфером глубины](poi_depth_buffer.png)

Да, иконки начинают скрываться зданиями, однако вовсе не таким способом, каким ожидаешь - видно, что иногда здание отъедает кусок POI или часть надписи, делая ее нечитабельной.

Поэтому мы стали продумывать альтернативные способы решения.
## Аналитический подход

Аналитический подход предполагает расчет скрытия на CPU при помощи алгоритмов [бросания луча](https://ru.wikipedia.org/wiki/Ray_casting).

![[ray_casting.png]]

Из камеры по направлению к каждой POI кидается луч, для которого проверяется пересечение с каждым 3D объектом.

У нас на карте запросто может быть несколько тысяч POI и несколько тысяч 3D объектов на экране, что в итоге дает миллионы итераций. А проверку пересечения нужно проводить на каждый кадр, то есть максимум за 10-15мс. 

Итого:  не проходит по производительности.
## Отдельная сцена скрытия POI

В этом подходе мы сгружаем вычисления на GPU. Для этого во вспомогательном [фреймбуфере](https://ru.wikipedia.org/wiki/Кадровый_буфер)  отрисовываем POI вместе с 3D объектами с использованием буфера глубины и пользуемся данными из этого фреймбуфера в шейдерах, при  отрисовке основной сцены. Условно говоря, если под центром POI в фреймбуфере красный цвет, то считаем его видимым, если красного цвета нет, то скрытым. 

Вот так примерно это выглядит - тут фреймбуфер скрытия POI полупрозрачно наложен на основную сцену.

![Скрытие POI при помощи вспомогательного фреймбуфера](labels_scene.jpg)

Отрисовка отдельного фреймбуфера влечет за собой накладные расходы по производительности, впрочем не столь большие как при аналитическом подходе. К тому же их можно уменьшить, снизив разрешение этого фреймбуфера. На картинке этот фреймбуфер имеет в 2 раза меньшее разрешение, это видно в виде большой пикселизованности красных областей.

В результате мы практически достигли нужно результата, но остался один момент:

![Моргание POI](poi_flickering.mov){width=100%}

Теперь POI начали скрываться целиком и не обрезаться прилегающими зданиями, однако они стали неприятно мерцать.

Причина этого кроется в том, что при пересечении POI и 3D-объекта возникают пиксельные решетки, при проходе по которым центра POI (по которому мы судим о видимости) слишком часто меняются состояния

![Пример пиксельной решетки](pixel_facet.png)

Преимущество данного подхода - скорость работы обернулась для нас недостатком. 

Борьба с пиксельной решеткой впоследствии оказалась достаточно нетривиальным делом, но в итоге мы остановились на этом способе, хоть и несколько модифицированном. 
## Асинхронная сцена скрытия

Другой наш подход заключался в том, чтобы мы расчитывали вспомогательный фреймбуфер не каждый кадр, а гораздо реже - где-то раз в 100-150мс и использовать его результаты в JS.

Для этого нам нужно отрисовать вспомогательный фреймбуфер и скачать его обратно из GPU в память CPU. После этого можно заглядывать в пикселы так же как и в шейдерах, благо спроецировать центр POI в координаты экрана является делом достаточно несложным.

Данный подход был нами реализован и нам удалось победить мерцание POI. Однако редкая отрисовка и последующее скачивание вспомогательного буфера приводили к отложенным изменениям в расположении POI на экране -- они долго изменяли свою конфигурацию после отзума или поворота карты.

![Асинхронная сцена скрытия](async_hide.mov){width=100%}

Итого: неплохо, но все же недостаточно быстро.

## Итого 

Не хотелось бы использовать избитые формулировки, но к данной фиче как нельзя лучше подходит "Было трудно, но мы справились". 

![Итоговая работа скрытия](final.mov){width=100%}

Фича получилась и она на бою. Мерцание POI до конца мы победить не смогли и оно все равно изредка происходит в особо сложных геометрических ситуациях. Будем надеяться, что в будущем мы найдем силы полностью искоренить эту проблему. 

Зато теперь стало значительно проще понять, где именно находится POI, и можно рассматривать наши красивые 3D-модели без помех.

